#!/bin/bash

# Define color codes
GREEN='\033[0;32m'
GREEN_BG='\033[37;42m'
YELLOW='\033[0;33m'
RED='\033[37;41m'
NC='\033[0m' # No Color

# Function to print menu
print_main_menu() {
    echo -e "${GREEN}\n  _____"
    echo -e " |   __|_____ ___ _____ "
    echo -e " |__   |     | -_|     |"
    echo -e " |_____|_|_|_|___|_|_|_|\n${NC}"
    echo -e "${GREEN_BG} Smem -  Linux Multitool ${NC}\n"
    echo "  1) Setup"
    echo "  2) Apps"
    echo "  3) Credits"
    echo -e "  q) Quit\n"
}

# Function to print the setup menu
print_setup_menu() {
    echo -e "\n${GREEN_BG} Setup Menu ${NC}\n"
    echo "  1) Setup improved + themed shell (requires zsh, fastfetch)"
    echo -e "  q) Return to Main Menu\n"
}

print_apps_menu() {
    echo -e "\n${GREEN_BG} Apps Menu ${NC}\n"
    echo "  1) Install paxs (Arch package helper for system, AUR, flatpak and snapd packages)"
    echo -e "  q) Return to Main Menu\n"
}

# Function to handle setup options
setup() {
    while true; do
        print_setup_menu
        read -p "Select an option: " setup_option

        case $setup_option in
            1)
                echo "Setting up zsh (requires zsh, fastfetch)..."
                setup_zsh
                ;;
            q|Q)
                echo -e "${GREEN}Returning to Main Menu...${NC}"
                break
                ;;
            *)
                echo -e "${RED}Invalid option. Please select 1 or q.${NC}"
                ;;
        esac

        echo # Empty line for better readability
    done
}

# Function to handle setup options
apps() {
    while true; do
        print_apps_menu
        read -p "Select an option: " setup_option

        case $setup_option in
            1)
                echo "Installing paxs..."
                install_paxs
                ;;
            q|Q)
                echo -e "${GREEN}Returning to Main Menu...${NC}"
                break
                ;;
            *)
                echo -e "${RED}Invalid option. Please select 1 or q.${NC}"
                ;;
        esac

        echo # Empty line for better readability
    done
}

# Function for installing zsh-script
setup_zsh(){
    # Confirm action
    echo -e "\n${YELLOW}This option modifies your shell environment and installs new fonts.${NC}"
    read -p "Are you sure you want to do it? (y/n): " choice
    case $choice in
        [Yy]* )
            ;;
        [Nn]* )
            echo "Action canceled."
            return 1
            ;;
        * )
            echo "Invalid selection. Cancelling..."
            return 1
            ;;
    esac

    # Define an array of required commands
    required_commands=("zsh" "fastfetch")

    # Initialize a flag to track the installation status
    all_installed=true

    # Function to check if a command is installed
    check_command() {
        command -v "$1" &> /dev/null
    }

    # Loop through each required command and check if it's installed
    for cmd in "${required_commands[@]}"; do
        if ! check_command "$cmd"; then
            echo "${RED}$cmd is not installed.${NC}"
            all_installed=false
        fi
    done

    # Return status code based on whether all commands are installed
    if not $all_installed; then
        echo "One or more required commands are missing. Cancelling..."
        exit 1
    fi

    # Setup zsh
    echo -e "${GREEN}Setting zsh as default shell...${NC}"

    # Check if the current shell is zsh
    if [ "$SHELL" != "$(which zsh)" ]; then
        echo -e "${GREEN}Changing the default shell to zsh...${NC}"

        # Attempt to change the default shell to zsh
        if ! chsh -s "$(which zsh)"; then
            echo -e "${RED}Error: chsh command failed. Authentication may be required or the shell may not be available.${NC}"
            exit 1
        fi

        echo -e "${GREEN}Default shell changed to zsh successfully. Please log out and log back in for the change to take effect.${NC}"
    else
        echo -e "${GREEN}The current shell is already zsh.${NC}"
    fi

    # Backup and remove existing .zshrc if it exists
    if [ -f "$HOME/.zshrc" ]; then
        echo -e "${GREEN}Backing up .zshrc...${NC}"

        # Determine the next available backup filename
        backup_file="$HOME/.zshrc.backup"
        counter=1
        while [ -f "$backup_file" ]; do
            backup_file="$HOME/.zshrc.backup${counter}"
            counter=$((counter + 1))
        done

        # Create the backup
        cp "$HOME/.zshrc" "$backup_file"
        echo -e "${GREEN}Backup created at $backup_file${NC}"

        echo -e "${GREEN}Removing existing .zshrc...${NC}"
        rm "$HOME/.zshrc"
    fi

    # Create a new .zshrc file with the provided settings
    echo -e "${GREEN}Creating new .zshrc...${NC}"

    cat << 'EOF' > "$HOME/.zshrc"
# Set the directory we want to store zinit and plugins
ZINIT_HOME="${XDG_DATA_HOME:-${HOME}/.local/share}/zinit/zinit.git"

# Download Zinit, if it's not there yet
if [ ! -d "$ZINIT_HOME" ]; then
mkdir -p "$(dirname $ZINIT_HOME)"
git clone https://github.com/zdharma-continuum/zinit.git "$ZINIT_HOME"
fi

# Source/Load zinit
source "${ZINIT_HOME}/zinit.zsh"

# Add in Powerlevel10k
zinit ice depth=1; zinit light romkatv/powerlevel10k

# Add in zsh plugins
zinit light zsh-users/zsh-syntax-highlighting
zinit light zsh-users/zsh-completions
zinit light zsh-users/zsh-autosuggestions

alias ls='ls --color=auto'
alias grep='grep --color=auto'
alias neofetch='fastfetch -c neofetch'
alias bottles='flatpak run com.usebottles.bottles'

bindkey "^[[1;5C" forward-word
bindkey "^[[1;5D" backward-word

fastfetch --logo small --separator-string "  " -s title:break:host:os:terminal:datetime:battery:break:colors --colors-symbol triangle

# To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.
[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh
EOF

    # -- Font Install --

    # Font download URLs
    FONT_URLS=(
    "https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Regular.ttf"
    "https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Bold.ttf"
    "https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Italic.ttf"
    "https://github.com/romkatv/powerlevel10k-media/raw/master/MesloLGS%20NF%20Bold%20Italic.ttf"
    )

    # Corresponding font file names
    FONT_FILES=(
    "MesloLGS NF Regular.ttf"
    "MesloLGS NF Bold.ttf"
    "MesloLGS NF Italic.ttf"
    "MesloLGS NF Bold Italic.ttf"
    )

    # Create a directory for fonts if it doesn't exist
    FONT_DIR="$HOME/.local/share/fonts"
    mkdir -p "$FONT_DIR"

    # Function to download font with retry mechanism
    download_font() {
    local url=$1
    local retries=6
    local count=0
    while [ $count -lt $retries ]; do
        wget -P "$FONT_DIR" "$url" && break
        count=$((count + 1))
        echo -e "${GREEN}Retry $count/$retries...${NC}"
    done
    if [ $count -eq $retries ]; then
        echo -e "${RED}Failed to download $url after $retries attempts.${NC}"
    fi
    }

    # Download fonts
    echo -e "${GREEN}Downloading fonts...${NC}"
    for url in "${FONT_URLS[@]}"; do
    download_font "$url"
    done

    # Update font cache
    echo -e "${GREEN}Updating font cache...${NC}"
    fc-cache -fv

    # Check if fonts are installed correctly
    echo -e "${GREEN}Verifying font installation...${NC}"
    ALL_FONTS_INSTALLED=true

    for i in "${!FONT_FILES[@]}"; do
    if [[ ! -f "$FONT_DIR/${FONT_FILES[$i]}" ]]; then
        echo -e "${RED}Font not installed correctly, please install manually:${NC} ${FONT_URLS[$i]}"
        ALL_FONTS_INSTALLED=false
    fi
    done

    if [ "$ALL_FONTS_INSTALLED" = true ]; then
    echo -e "${GREEN}All fonts installed successfully!\n${NC}"
    else
    echo -e "${RED}Some fonts were not installed correctly. Check the red text above.${NC}\n"
    fi

    # -- End Font Install --

    echo -e "${GREEN}INSTALLATION FINISHED\n\nSelect MesloLGS NF as your Terminal font.\nA reboot may be required for the new default shell to take effect.\nYou will be prompted to make theming selections the next time you open your new default shell.${NC}"
}

# Function for installing paxs
install_paxs() {
# Define an array of required commands
required_commands=("yay" "flatpak" "snap" "grep")

# Initialize a flag to track the installation status
all_installed=true

# Function to check if a command is installed
check_command() {
    command -v "$1" &> /dev/null
}

# Loop through each required command and check if it's installed
for cmd in "${required_commands[@]}"; do
    if ! check_command "$cmd"; then
        echo "${RED}$cmd is not installed.${NC}"
        all_installed=false
    fi
done

# Return status code based on whether all commands are installed
if not $all_installed; then
    echo "One or more required commands are missing. Cancelling..."
    exit 1
else
    yay -S paxs
    exit 0
fi
}

# Function for option 3
credits() {
echo -e "\n\n _  _ __ |_  _  _| _ __  o  _ "
echo -e " /_(_||||| |(/_(_|(_)| | | (_|"
echo -e "                                2024\n"
    read -p ""
}

# Main loop
while true; do
    print_main_menu
    read -p "Select an option: " option

    case $option in
        1)
            setup
            ;;
        2)
            apps
            ;;
        3)
            credits
            ;;
        q|Q)
            echo -e "${GREEN}Quitting...${NC}"
            break
            ;;
        *)
            echo -e "${RED}Invalid option. Please select 1, 2, 3, or q.${NC}"
            ;;
    esac

    echo # Empty line for better readability
done
